\chapter{Algoritmy řešící [n,k]-Mastermind}

\section{Kategorie algoritmů}
% přidat definici algoritmu, který řeší mastermind - vytvoří posloupnost kódů, která končí tajným kódem s nejlepším ohodnocením. 
Algoritmy řešící hru Mastermind lze rozdělit do dvou kategorií, \emph{deterministické} a \emph{nedeterministické}. Deterministický algoritmus pro dva shodné stavy volí další krok vždy jednoznačně. 
%Nemůže se tedy stát, že by deterministický algoritmus pro dva stejné vstupy vrátil odlišné výsledky. 
Nedeterministické algoritmy naproti tomu mohou mít v každém stavu na výběr z více následujících kroků. Volit mohou například podle nějakého pravděpodobnostního rozdělení. Není tedy zaručeno, že pro stejný vstup vrátí vždy identický výsledek.

Deterministické algoritmy řešící hru Mastermind mohou mít velikou časovou složitost. To se snaží řešit nedeterministické algoritmy, které hledají rovnováhu mezi časovou složitostí a dobrými výsledky. 
% Hlavní předností deterministických algoritmů je záruka výsledku. Na druhou stranu ale tyto typy algoritmů mohou mít velikou časovou složitost, protože jsou často založeny na procházení všech možností pokračování. To se snaží řešit nedeterministické algoritmy, které hledají rovnováhu mezi časovou složitostí a dobrými výsledky. 
V této práci budeme zkoumat pouze deterministické algoritmy. 

% šlo by zmínit výhody a nevýhody (ne)deterministických algoritmů
% Popsat algoritmy, které hrají pouze kandidáty????


\section{Deterministické algoritmy}
% mozna napsat pozdeji ... Všechny deterministické algoritmy, které budeme srovnávat ...

\subsubsection{Stav hry}
V každém kroku algoritmů vycházíme z určitého stavu hry, pro který daná metoda vybírá další pokus. Stav je posloupnost pokusů s ohodnocením a jsou to přesně ty informace, které má hráč [n,k]-Mastermindu k dispozici, a na základě kterých volí následující tah.

\begin{definice}[Stav]\label{stav}
   Nechť $j \in \mathbb{N}$, $u_1, \dots , u_j \in H_{n,k}$ jsou kódy a $r_1, \dots, r_j \in S_{n,k}$ ohodnocení. \emph{Stav} definujeme jako posloupnost $((u_1, r_1), \dots, (u_m, r_m))$. Počáteční stav definujeme jako prázdnou posloupnost $()$.
\end{definice}

% Vazby stavů budeme interpretovat jako v kořenovém stromu, kde vrcholy odpovídají stavům. Hrany znázorňují pokusy s ohodnocením, které [n,k]-Mastermind posouvají do dalších stavů. 

% definice inspirovaná matoušek nešetřil
\begin{definice}[Orientovaný graf]
    Orientovaný graf $G$ je uspořádaná dvojice $(V,E)$, kde $V$ je množina a $E \subseteq V\times V$ je množina uspořádaných dvojic. Prvky $V$ nazýváme vrcholy a prvky $E$ hrany. Řekneme, že z vrcholu $a \in V$ do vrcholu $b \in V$ vede hrana, pokud $(a,b) \in E$. 
\end{definice}

Stavy hry a vazby mezi nimi popíšeme orientovaným grafem. Hrany znázorňují pokusy s ohodnocením, které hru [n,k]-Mastermind posouvají do dalších stavů. 
\begin{definice}[Strom \text{[n,k]-Mastermindu}]
  \emph{Strom [n,k]-Mastermindu} definujeme jako orientovaný graf na množině všech stavů. Kořenem je počáteční stav. Ze stavu $A = \left((u_1, r_1),\dots, (u_j,r_j)\right)$ do stavu $B = \left((w_1, s_1), \dots, (w_l,s_l)\right)$ vede hrana právě tehdy, když $l = j+1$ a pro všechna $ i \in \{1,2,\dots, j\}$ platí $ (u_i, r_i) = (w_i, s_i)$. Tato hrana má obarvení $(w_l, s_l)$. 
\end{definice}
\begin{pozn}
    Strom [n,k]-Mastermindu je kořenový strom.
\end{pozn}

Obrázek \ref{fig22prvnitah} zobrazuje počáteční stav [2,2]-Mastermindu a všechny stavy, do kterých se lze dostat po prvním pokusu. 


\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \node (1) at (0,0) {$()$};
    
    \node (2) at (-3,-3) {$((11,(0,0)))$};
    \draw[->,blue] (1) -- (2) node[pos=0.5, below, sloped] {\footnotesize$(11,(0,0))$};
    \node (3) at (0,-3) {$((11,(1,0)))$};
    \draw[->,blue] (1) -- (3) node[pos=0.5, below, sloped] {\footnotesize$(11,(1,0))$};
    \node (4) at (3,-3) {$((11,(2,0)))$};
    \draw[->,blue] (1) -- (4) node[pos=0.5, below, sloped] {\footnotesize$(11,(2,0))$};
    
    \node (5) at (6,-2) {$((12,(0,2)))$};
    \draw[->,black!60!green] (1) -- (5) node[pos=0.5, above, sloped] {\footnotesize$(12,(0,2))$};
    \node (6) at (6,0) {$((12,(1,0)))$};
    \draw[->,black!60!green] (1) -- (6) node[pos=0.5, above, sloped] {\footnotesize$(12,(1,0))$};
    \node (7) at (6,2) {$((12,(2,0)))$};
    \draw[->,black!60!green] (1) -- (7) node[pos=0.5, above, sloped] {\footnotesize$(12,(2,0))$};

    \node (8) at (-3,3) {$((21,(0,2)))$};
    \draw[->] (1) -- (8) node[pos=0.5, above, sloped] {\footnotesize$(21,(0,2))$};
    \node (9) at (0,3) {$((21,(1,0)))$};
    \draw[->] (1) -- (9) node[pos=0.5, above, sloped] {\footnotesize$(21,(1,0))$};
    \node (10) at (3,3) {$((21,(2,0)))$};
    \draw[->] (1) -- (10) node[pos=0.5, above, sloped] {\footnotesize$(21,(2,0))$};

    \node (11) at (-6,-2) {$((22,(0,0)))$};
    \draw[->,red] (1) -- (11) node[pos=0.5, above, sloped] {\footnotesize$(22,(0,0))$};
    \node (12) at (-6,0) {$((22,(1,0)))$};
    \draw[->,red] (1) -- (12) node[pos=0.5, above, sloped] {\footnotesize$(22,(1,0))$};
    \node (13) at (-6,2) {$((22,(2,0)))$};
    \draw[->,red] (1) -- (13) node[pos=0.5, above, sloped] {\footnotesize$(22,(2,0))$};


    \end{tikzpicture}
    \caption{Graf všech následníků počátečního stavu [2,2]-Mastermindu}
    \label{fig22prvnitah}
\end{figure}

Stavy, do kterých ze stavu $A$ vede nějaká hrana nazýváme následníky stavu $A$. 
%Zavádíme definici potomka množiny, která s potomkem stavu přímo souvisí. 

\begin{definice}[Následník stavu]\label{potomek}
  % Uvažujme [n,k]-Mastermind s nějakým tajným kódem $v\in H_{n,k}$. 
  % Nechť $S$ je množina všech ohodnocení v $H_{n,k}$. Nechť $A = \left((u_1, r_1), \dots, (u_j,r_j)\right)$ je stav, $u \in H_{n,k}$ je kód a $r \in S$ ohodnocení. Potomka stavu $A$ vzhledem ke kódu $u$ a ohodnocení $r$ definujeme jako stav $A_{u,r} = (\left((u_1, r_1), \dots, (u_j,r_j) ,(u,r)\right)$. 
  
  \emph{Následník stavu $A$ vzhledem ke kódu $u$ a ohodnocení $r$} je stav, do kterého vede ze stavu $A$ hrana obarvená $(u,r)$. Značíme jej $A_{u,r}$. 
  
  %Nechť $K \subseteq H_{n,k}$ je množina kódů, potom potomka množiny $K$ vzhledem ke kódu $u$ a ohodnocení $r$ definujeme jako množinu
  %\[K_{u,r} = \{w \in K \mid s(u,w) = r\}.\] 
\end{definice}

Průběh [n,k]-Mastermindu s nějakým tajným kódem $v$ lze sledovat ve stromu [n,k]-Mastermindu. Nechť $A$ je stav a hráč zvolí další pokus $u$. Touto volbou hráč vybral část následníků, do kterých se stav hry může dostat. Jsou to právě následníci stavu $A$ vzhledem ke kódu $u$. Zadavatel ohodnotí kód $u$ vzhledem ke kódu $v$ ohodnocením $r$. Ohodnocením určí, který stav z následníků $A$ vzhledem ke kódu $u$ bude následovat. Hráč tedy může vybrat jako následující pokus ten, který bude mít nejvhodnější vrstvu následníků stavu $A$ (například podle množin kandidátů definovaných níže). Z těchto následníků ale neví, do kterého se hra dostane, protože nezná ohodnocení s tajným kódem. 


\subsubsection{Kandidát}
Pro každý stav lze nalézt množinu kódů, které by podle dostupných informací mohly být tajným kódem. 
% Jde o ty kódy, které mají s kódy ve stavu stejné ohodnocení jako příslušná ohodnocení ve stavu. 

\begin{definice}[Množina kandidátů]\label{kandidat}
  Pro počáteční stav definujeme \emph{množinu kandidátů} jako celý prostor kódů $H_{n,k}$. Nechť $A = \left((u_1, r_1), \dots, (u_j,r_j)\right), u_i \in H_{n,k}, r_i \in S_{n,k}$ je stav. \emph{Množinu kandidátů} stavu $A$ definujeme jako
  \[K = \{w \in H_{n,k} \mid s(w,u_i) = r_i,  i \in \{1,2,\dots ,j\} \}.\]
  Kód z této množiny nazveme \emph{kandidát} stavu $A$. 
  
  %Řekneme, že kód $u \in H_{n,k}$ je kandidát stavu $A$, pokud $s(u,u_i) = r_i \hspace{5px} \forall i \in \{1, \dots j\}$. 

  % Dále definujeme funkci $J$, která stavu přiřadí jeho množinu kandidátů.
  % \begin{align*}
  %     J \colon (H_{n,k} \times S)^+ &\to \mathbb{R} \\
  %       \left((u_1, r_1), (u_2,r_2), \dots, (u_j,r_j)\right) &\mapsto \{u \in H_{n,k} \mid s(u,u_i) = r_i \hspace{5px} \forall i \in \{1, \dots j\} \} 
  % \end{align*}
\end{definice}
Velikost a struktura množiny kandidátů určuje, jak blízko jsme uhodnutí tajného kódu.
% Množina kandidátů dává intuici za tím, jak blízko jsme uhádnutí tajného kódu. V případě, že množina kandidátů je jednoprvková, tak nám je znám tajný kód. Pokud je množina kandidátů veliká, nejspíš ještě budeme k rozlišení tajného kódu potřebovat více pokusů.
\begin{definice}[Potomek množiny]\label{defpotomekmnoziny}
  % Uvažujme [n,k]-Mastermind s nějakým tajným kódem $v\in H_{n,k}$. Nechť $S$ je množina všech ohodnocení v $H_{n,k}$. 
  Nechť $K \subseteq H_{n,k}$ je množina kódů, $u \in H_{n,k}$ je kód a $r \in S_{n,k}$ je ohodnocení. \emph{Potomka množiny $K$, vzhledem ke kódu $u$ a ohodnocení $r$} definujeme jako množinu 
  \[K_{u,r} = \{w \in K \mid s(w,u) = r\}.\] 
\end{definice}
Z definice plyne
\[\bigcup_{r\in S_{n,k}} K_{u,r} \subseteq K.\] Zároveň žádný kód $w \in K$ nemůže mít s kódem $u$ dvě různá ohodnocení, a tedy sjednocení je disjunktní. Navíc pro každý kód $w \in K$ platí, že $w \in K_{u, s(w,u)}$, a tedy platí následující lemma.

\begin{lemma}[Vztah množiny s jejími potomky]\label{lemmadisjunktnipotomci}
    % Nechť $S_{n,k}$ je množina všech ohodnocení kódů v $H_{n,k}$. 
    Pro každou množinu $K \subseteq H_{n,k}$ a kód $u \in H_{n,k}$ platí
    \[K = \bigsqcup_{r\in S_{n,k}} K_{u,r}.\]
\end{lemma}


% \begin{dukaz}
%     Dokážeme obě inkluze. Z definice $K_{u,r}$ platí 
%     \[\bigsqcup_{r\in S} K_{u,r} \subseteq K.\] 
%     Nechť $u \in H_{n,k}$. Potom pro každý kód $w \in K$ platí, že $w \in K_{u, s(u,w)}$ a tedy 
%     \[K \subseteq \bigsqcup_{r\in S} K_{u,r}.\] 
%     Zároveň žádný kód $w \in K$ nemůže mít s kódem $u$ dvě různá ohodnocení, a tedy sjednocení je disjunktní. 
% \end{dukaz}

% \begin{definice}[Graf \text{[n,k]-Mastermindu}]
%   Uvažujeme množinu vrcholů $\mathcal{V} = \mathcal{P}(H_{n,k})$ a množinu orientovaných hran $\mathcal{E}$ mezi vrcholy a jejich potomky. 
%   Cestu definujeme jako posloupnost navazujících hran. 
%   Definujeme $V \subseteq \mathcal{V}$ jako množinu vrcholů, do kterých vede cesta z vrcholu $H_{n,k}$. Graf [n,k]-Mastermindu definujeme jako indukovaný podgraf grafu $(\mathcal{V}, \mathcal{E})$ množinou $V$. Hranu $(K, K_{u,r})$ budeme značit jako hranu $(u,r)$ z vrcholu $K$.
% \end{definice}
\begin{lemma}[Vztah následníků a potomků]\label{lemmavztahnaslednikuapotomku}
    Uvažujme prostor kódů $H_{n,k}$. Nechť $A = \left((u_1, r_1), \dots, (u_j,r_j)\right)$ je stav a $K$ množina jeho kandidátů. Potom pro všechny kódy $u\in H_{n,k}$ a ohodnocení $r \in S_{n,k}$ platí, že $K_{u,r}$ je množina kandidátů stavu $A_{u,r}$.
    % stavu $A = \left((u_1, r_1), \dots, (u_j,r_j)\right)$, 
\end{lemma}
\begin{dukaz}
    Rozepíšeme z definic. 
    $K_{u,r} = \{w \in K \mid s(u,w) = r\}$ a $K = \{w \in H_{n,k} \mid s(u_i,w) = r_i,  i \in \{1,2,\dots ,j\} \}$. Tedy celkem 
    $K_{u,r} = \{w \in H_{n,k} \mid s(u_i,w) = r_i,  i \in \{1,2,\dots ,j\} \land s(u,w) = r\}$.
    Navíc platí, že $A_{u,r} = \left((u_1, r_1), \dots, (u_j,r_j), (u,r)\right)$. Lemma plyne z definice množiny kandidátů.
\end{dukaz}
Z lemmatu plyne, že potomci $K$ vzhledem ke kódu $u$ určují množiny kandidátů možných následující stavů v případě, kdy zvolíme kód $u$ jako další pokus. Množiny a jejich vztah s potomky zapíšeme do grafu. 

\begin{definice}[Orientovaný multigraf]
    Orientovaný multigraf definujeme jako dvojici $G = (V,E)$, kde $E \subseteq V \times V$ je množina povolující opakování prvků (dále jako multimnožina). Navíc každý prvek $e\in E$ má přiřazené obarvení $q \in Q$ z množiny obarvení $Q$. Obarvení jednoznačně rozlišuje duplicitní prvky v $E$. 
\end{definice}
\begin{definice}[Multigraf prostoru kódů]
  Nechť $n, k\in \mathbb{N}$, $u\in H_{n,k}$ je kód a $r\in S_{n,k}$ je ohodnocení. Multigraf prostoru kódů definujeme jako orientovaný multigraf $G_{n,k} = (\mathcal{V}, \mathcal{E})$. $\mathcal{V} = \mathcal{P}(H_{n,k})$ je množina vrcholů. $\mathcal{E} \subseteq \mathcal{V} \times \mathcal{V}$ je multimnožina hran, pro kterou platí, že z vrcholu $K_1$ do vrcholu $K_2$ vede hrana obarvená $(u,r)$, právě tehdy, když $K_2$ je potomek $K_1$ vzhledem ke kódu $u$ a ohodnocení $r$. 
  % Každá hrana je jednoznačně určená počátečním vrcholem a obarvením $(u,r)$. 
  % kde každá hraná má přiřazené obarvení $r\in S_{n,k}$. 
\end{definice}
% Hrany v multigrafu jsou obarvené 

\begin{definice}[Orientovaná cesta]
    \emph{Orientovanou cestu} (dále jen cestu) definujeme jako posloupnost navazujících hran a značíme ji posloupností obarvení hran $A = ((u_1,r_1), \dots, (u_j, r_j))$. Konstantní cestu na vrcholu $K$ značíme jako prázdnou posloupnost $A = ()$. Řekneme, že do vrcholu $K_2$ vede z vrcholu $K_1$ cesta $A$, pokud se z vrcholu $K_1$ dostaneme do vrcholu $K_2$ posloupností hran jednoznačně určenými začátkem a obarveními z $A$. Konstantní posloupnost vede do počátečního vrcholu. 
    % Řekneme, že do vrcholu $K_2$ vede cesta z vrcholu $K_1$, pokud se z vrcholu $K_1$ dostaneme do vrcholu
\end{definice}

\begin{pozn}
    Nechť $G = (V,E)$ a $G_2 = (V_2, E_2)$ jsou orientované grafy a $V_2 \subseteq V$. Řekneme, že $G_2$ je podgraf grafu $G$, pokud $E_2 \subseteq V_2 \times V_2$ a zároveň $E_2 \subseteq E$.
    Řekneme, že $G_2$ je podgraf grafu $G$ indukovaný množinou $V_2$, pokud $E_2 =  E \cap V_2\times V_2$.
\end{pozn}


\begin{definice}[Multigraf {[n,k]-Mastermindu}]
  \emph{Multigraf [n,k]-Mastermindu} definujeme jako podgraf multigrafu $G_{n,k}$ indukovaný množinou vrcholů, do kterých vede cesta z vrcholu $H_{n,k}$. Značíme ho $G_{n,k}^*$.
  
  %a množinu orientovaných hran $\mathcal{E}$ mezi vrcholy a jejich potomky. 
  %Cestu definujeme jako posloupnost navazujících hran. 
  %Definujeme $V \subset \mathcal{V}$ jako množinu vrcholů, do kterých vede cesta z vrcholu $H_{n,k}$. Graf [n,k]-Mastermindu definujeme jako indukovaný podgraf grafu $(\mathcal{V}, \mathcal{E})$ množinou $V$. Hranu $(K, K_{u,r})$ budeme značit jako hranu $(u,r)$ z vrcholu $K$.
\end{definice}
Z lemmatu \ref{lemmavztahnaslednikuapotomku} o vztahu následníků a potomků plyne, že vrcholy multigrafu [n,k]-Mastermindu jsou právě ty množiny, které odpovídají množinám kandidátů nějakého stavu. Mezi dvěma vrcholy může vést více hran, jak je vidět na obrázku \ref{fig22prvnitahmnoziny}, který zobrazuje potomky $H_{2,2}$ vzhledem ke všem kódům a ohodnocením. 

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \node (1) at (0,0) {\{11,12,21,22\}};
    \node (4) at (-5,0) {\{11\}};
    \draw[->] (1) to[out=165, in=30]  node[midway, below, sloped] {\footnotesize$(11,(2,0))$} (4);
    \draw[->] (1) to[out=-165, in=-30] node[pos=0.5, below, sloped] {\footnotesize$(22,(0,0))$} (4);
    \node (7) at (-3,4) {\{12\}};
    \draw[->] (1) to[out=150, in=-90] node[pos=0.5, above, sloped] {\footnotesize$(12,(2,0))$} (7) ;
    \draw[->] (1) to[out=120, in=-30] node[pos=0.5, above, sloped] {\footnotesize$(12,(2,0))$} (7);
    \node (5) at (3,4) {\{21\}};
    \draw[->] (1) to[out=90, in=-150] node[pos=0.5, above, sloped] {\footnotesize$(12,(0,2))$} (5);
    \draw[->] (1) to[out=60, in=-90] node[pos=0.5, above, sloped] {\footnotesize$(21,(2,0))$} (5);
    \node (2) at (5,0) {\{22\}};
    \draw[->] (1) to[out=15, in=150] node[midway, above, sloped] {\footnotesize$(11,(0,0))$} (2);
    \draw[->] (1) to[out=-15, in=-150] node[midway, above, sloped] {\footnotesize$(22,(2,0))$} (2);
    \node (6) at (3,-4) {\{11, 22\}};
    \draw[->] (1) to[out=-30, in=90] node[pos=0.5, above, sloped] {\footnotesize$(12,(1,0))$} (6);
    \draw[->] (1) to[out=-60, in=150] node[pos=0.5, above, sloped] {\footnotesize$(21,(1,0))$} (6);
    \node (3) at (-3,-4) {\{12, 21\}};
    \draw[->] (1) to[out=-120, in=90] node[midway, below, sloped] {\footnotesize$(11,(1,0))$} (3);
    \draw[->] (1) to[out=-90, in=30] node[midway, below, sloped] {\footnotesize$(22,(1,0))$} (3);
    \end{tikzpicture}
    \caption{Multigraf všech potomků $H_{2,2}$}
    \label{fig22prvnitahmnoziny}
\end{figure}

% zdroj - wikipedie, https://en.wikipedia.org/wiki/Directed_acyclic_graph
\begin{definice}[Orientovaný acyklický multigraf]
    Řekneme, že orientovaný multigraf je orientovaný acyklický, pokud neexistuje nekonstantní cesta, která začíná i končí ve stejném vrcholu.
\end{definice}

\begin{lemma}
    Multigraf [n,k]-Mastermindu je orientovaný acyklický. 
\end{lemma}
\begin{dukaz}
    Nechť $K_1$ a $K_2$ jsou různé vrcholy ($K_2 \neq K_1$) multigrafu [n,k]-Mastermindu. 
    Pokud existuje nějaká cesta začínající i končící v $K_1$ vedoucí přes vrchol $K_2$, tak potom díky lemmatu \ref{lemmadisjunktnipotomci} platí $K_1 \subset K_2 \subset K_1$, což je spor. Tedy neexistuje žádná nekonstantní cesta začínající i končící ve stejném vrcholu.
\end{dukaz}

Z lemma plyne fakt, že multigraf [n,k]-Mastermindu má kořen, kterým je celý prostor kódů. Ve spojení s právě definovanou vlastností dostáváme podobnost multigrafu [n,k]-Mastermindu s kořenovým stromem [n,k]-Mastermindu. Tento vztah popíšeme formálně pomocí takzvaného rozvinutí.
% multigraf je "directed acyclic graph"
\begin{definice}[Rozvinutí orientovaného acyklického multigrafu]
    Nechť $G$ je souvislý orientovaný acyklický multigraf s jedním kořenem (vrcholem, do kterého nevedou žádné hrany). 
    Potom definujeme jeho rozvinutí jako orientovaný graf $T = (V, E)$.
    % , kde $V$ je množina vrcholů a $E$ množina hran definované následovně.
    Množina vrcholů $V$ je množina cest z kořene multigrafu $G$.
    $E$ je množina hran taková, že z vrcholu $A \in V$ do vrcholu $B \in V$ vede hrana právě tehdy, když cesta $B$ vznikne z cesty $A$ prodloužením o jednu hranu. Tato hrana je obarvená poslední hranou cesty $B$. 
\end{definice}
\begin{pozn}\label{poznobarvenivrcholurozvinuti}
    Vrchol rozvinutí orientovaného acyklického multigrafu odpovídající cestě $A$ lze obarvit vrcholem původního multigrafu, do kterého tato cesta vede. V případě [n,k]-Mastermindu by obarvením byly množiny kandidátů stavu odpovídajícího konkrétní cestě. 
\end{pozn}


\begin{veta}
    Strom [n,k]-Mastermindu je rozvinutím multigrafu [n,k]-Mastermindu.
\end{veta}
\begin{dukaz}
    Z každého stavu ve stromě [n,k]-Mastermindu vedou hrany obarvené všemi kódy s ohodnoceními. Zároveň každá cesta v multigrafu [n,k]-Mastermindu lze prodloužit hranou obarvenou libovolným kódem s ohodnocením. Díky shodnému značení hran jsou grafy identické. Pro každý stav $A$ navíc díky lemmatu \ref{lemmavztahnaslednikuapotomku} platí, že jeho množina kandidátů je rovna vrcholu, do kterého vede cesta $A$ v multigrafu [n,k]-Mastermindu začínající ve vrcholu $H_{n,k}$. 

     % chceme předpoklad, že hrana je jednoznačně určená počátečním vrcholem a obarvením, chtělo by to zmínit při konstrukci multigrafu, nebo při definici/označení cest v multigrafu. 

     % Nechť $A$ je vrchol ve stromu [n,k]-Mastermindu, potom $A$ značí i nějakou cestu v multigrafu. Z tohoto vrcholu vedou všechny možné hrany stejně tak jako z rozvinutí multigrafu [n,k]-Mastermindu. 

     % Z každého stavu vedou hrany obarvené všemi kódy s ohodnoceními. To samé platí pro vrcholy na multigrafu. 
\end{dukaz}



% Multigraf [n,k]-Mastermindu 

% Díky Lemmatu \ref{lemmavztahnaslednikuapotomku} můžeme popsat vztah mezi stromem a grafem [n,k]-Mastermindu. Nějaký vrchol $K$ grafu je množina kandidátů všech stavů, které odpovídají cestám z $H_{n,k}$ do tohoto vrcholu. 

% \begin{tvrz}[Vztah multigrafu a stromu \text{[n,k]-Mastermindu}]\label{tvrzenimultigrafastrom}
%     Nechť $A = \left((u_1, r_1), (u_2,r_2), \dots, (u_j,r_j)\right)$ je stav. a $K_1$ je jeho množina kandidátů. Nechť $K_2$ odpovídá vrcholu na konci cesty $A$ z $H_{n,k}$ multigrafem [n,k]-Mastermindu. Potom $K_1 = K_2$.  
% \end{tvrz}
% \begin{dukaz}
%     Postupujeme indukcí podle délky stavu. Nechť délka stavu je $1$, tvrzení platí díky lemmatu \ref{lemmavztahnaslednikuapotomku}. Nechť tvrzení platí pro $j\in \mathbb{N}, j\geq 2$. Potom $A = B_{u_{j+1}, r_{j+1}}$ pro nějaký stav $B$, kde množinu kandidátů $B$ označíme $K$. Potom $K$ je konec cesty $B$ z $H_{n,k}$ multigrafem [n,k]-Mastermindu z indukčního předpokladu. Potom z lemmatu \ref{lemmavztahnaslednikuapotomku} platí, že $K_{u_j, r_j}$, která je koncem cesty $A$ z $H_{n,k}$, je množina kandidátů stavu $A$. 
% \end{dukaz}


 





\subsubsection{Strom algoritmu}
V této sekci definujeme takzvaný strom algoritmu. Je to způsob, jakým popsat průběh hry [n,k]-Mastermind pro všechny tajné kódy v případě pevně zvoleného algoritmu. 

\begin{definice}[Prázdný a koncový stav]\label{kandidat}
  % Nechť $A = \left((u_1, r_1), \dots, (u_j,r_j)\right), u_i \in H_{n,k}, r_i \in S_{n,k}$ je stav. 
  Řekneme, že stav $A$ je \emph{prázdný}, pokud je množina kandidátů tohoto stavu prázdná. Řekneme, že stav $A$ je \emph{koncový}, pokud je neprázdný a poslední člen je roven $(u,(n,0))$ pro nějaký kód $u$.
\end{definice}

Prázdný stav nemůže odpovídat průběhu hry Mastermind, protože v tu chvíli žádný kód nemůže být tajným kódem. V reálné hře by ho šlo dosáhnout pouze při chybě v ohodnocení pokusu. Koncový stav odpovídá konci hry, kdy se pokus shoduje s tajným kódem. Množina jeho kandidátů v tu chvíli obsahuje právě tajný kód. 


\begin{definice}[Strom algoritmu \text{[n,k]-Mastermindu}]
  Řekneme, že souvislý podgraf $T$ stromu [n,k]-Mastermindu je strom algoritmu, pokud splňuje následující podmínky.
  % Strom algoritmu definujeme jako souvislý podgraf stromu [n,k]-Mastermindu, který splňuje následující podmínky.
  \begin{enumerate}
      \item Neobsahuje prázdné stavy.
      \item Hrany vedoucí z každého vrcholu grafu $T$ jsou obarveny nejvýše jedním kódem. 
      \item Pro každý kód $w \in H_{n,k}$ má graf $T$ právě jeden koncový stav s posledním členem $(w, (n,0))$, který je zároveň listem v grafu $T$.
  \end{enumerate}
\end{definice}


\begin{lemma}[Množina kandidátů počátečního stavu]\label{lemmakandidatipocstavu}
    Množina kandidátů stavu $A$ je $H_{n,k}$ právě tehdy, když $A$ je počáteční stav.
\end{lemma}
\begin{dukaz}
    Množina kandidátů počátečního stavu je z definice celý prostor kódů. Stačí tedy dokázat implikaci zleva doprava. Nechť pro spor $A$ není počáteční stav. Označíme $K$ množinu jeho kandidátů. Bez újmy na obecnosti předpokládáme, že stav $A$ je složen právě z jednoho kódu s ohodnocením. Nechť $A = ((u, (b,w)))$. Pokud $(b,w) = (n,0)$, potom $K = \{u\}$. Pokud $(b,w) \neq (n,0)$, potom $u \notin K$. Tedy množina kandidátů stavu $A$ není $H_{n,k}$, což je spor. 
\end{dukaz}

\begin{tvrz}[Vlastnosti stromu algoritmu]\label{tvrzvlastnostistromualgoritmu}
    Pro strom algoritmu [n,k]-Mastermindu platí následující vlastnosti:
    \begin{enumerate}
        \item Má kořen a je jím počáteční stav. 
        \item Z každého nekoncového vrcholu vedou hrany do všech neprázdných potomků vzhledem k určitému kódu.
    \end{enumerate}
    
\end{tvrz}
\begin{dukaz}
    Strom algoritmu neobsahuje žádné orientované cykly (cesty se začátkem i koncem ve stejném vrcholu) díky definici hran.
    % ve stromě [n,k]-Mastermindu. 
    Zároveň do každého stavu (kromě počátečního) vede právě jedna hrana a díky souvislosti tedy strom algoritmu obsahuje nějaký kořen. Označíme $K$ jeho množinu kandidátů.

    Nyní využijeme lemmatu \ref{lemmavztahnaslednikuapotomku} o disjunktním sjednocení potomků množin kandidátů. Díky podmínce $2$ z definice stromu algoritmu jsou množiny kandidátů všech stavů ve stromu algoritmu podmnožinami $K$. Pokud $K \neq H_{n,k}$, existoval by kód $u \in H_{n,k} \setminus K$. Pokud by potom strom algoritmu obsahoval stav se členem $(u, (n,0))$, tento stav by byl prázdný. Nemohl by tedy pro tento kód existovat koncový stav. Množina kandidátů kořene je tedy rovna $H_{n,k}$. Z lemmatu \ref{lemmakandidatipocstavu} plyne, že kořenem je právě počáteční stav. 

    Pokud by z nějakého nekoncového stavu ve stromu algoritmu nevedly hrany do všech neprázdných následníků tohoto stavu vzhledem k určitému kódu, došli bychom opět 
    % , díky disjunktnímu rozkladu množiny do jejích potomků, 
    ke sporu s existencí koncového stavu pro nějaký kód. To plyne opět z disjunktního rozkladu množiny do jejích potomků z lemmatu \ref{lemmadisjunktnipotomci}.
    
    % Pokud by kořenem nebyl počáteční stav, množina kandidátů kořene by nebyla $H_{n,k}$ z lemmatu \ref{lemmakandidatipocstavu}. Množina kandidátů všech ostatních vrcholů ve stromu algoritmu je tedy podmnožinou $K$ z lemmatů \ref{lemmasjednocenipotomku} a \ref{lemmavztahnaslednikuapotomku}. 
    

    % Protože rozklad množiny $K$ na $K_{u,r}$ je disjunktní, tak je-li stav $A$, který není konečný, ve stromu algoritmu, budou tam poté i všichni neprázdní potomci stavu $A$ vzhledem k vybranému kódu $u_A$ (za splnění podmínky $1$). V opačném případě by stejně jako výše nebyla splněna podmínka $2$.
\end{dukaz}

% Nyní předpokládejme, že máme nějaký algoritmus výběru dalšího tahu a pro každý dosažitelný stav $A$ [n,k]-Mastermindu známe následující zahraný kód $u_A$. Potom lze sestavit takzvaný strom algoritmu, který zobrazuje pro každý stav $A$ potomky vzhledem k zahranému kódu $u_A$. 

% Prázdné stavy jsou vynechány, protože jsou v průběhu hry nedosažitelné. Potomky koncových stavů neuvažujeme, protože by to byly pokusy po konci hry. 

Uvažujme algoritmus výběru dalšího tahu, kdy pro každý stav $A$ známe následující zahraný kód $u_A$. Potom strom tohoto algoritmu lze sestavit rekurzivně, kdy pro každý stav $A$ přidáme do stromu potomky $A$ vzhledem k zahranému kódu $u_A$. Strom algoritmu popisuje průběh hry pro všechny tajné kódy. Jednotlivá kola [n,k]-Mastermindu s tajným kódem $v\in H_{n,k}$ odpovídají hranám cesty z počátečního stavu do koncového stavu s posledním prvkem $(v,(n,0))$. Příklad stromu algoritmu pro [2,2]-Mastermind ukazuje obrázek \ref{figprikladstromualgoritmu}. Ze stromu algoritmu tedy lze vyčíst počty pokusů, které algoritmus potřebuje k nalezení tajných kódů

    %Platí, že pro nějaký kód $u$ jsou množiny kandidátů potomků $A$ vzhledem ke kódu $u$ disjunktní a sjednocením dávají množinu kandidátů stavu $A$. Všechny stavy, do kterých se dostaneme cestou z nějakého stavu $A$ za dodržení podmínky $1$ tedy mají kandidáty z množiny kandidátů stavu $A$. 


%\begin{pozn}
    %Stavy budeme také označovat množinou kandidátů pro tento stav. Množina kandidátů neurčuje jednoznačně stav (například prohozením prvků stavu bychom došli do stejné množiny kandidátů). Naopak stav jednoznačně určuje množinu kandidátů. 
%\end{pozn}

\begin{figure}[h!]
    \centering
    \begin{tikzpicture}
    \node (1) at (0,0) {$()$};
    \node (2) at (-4,-2) {$((11,(0,0)))$};
    \draw[->] (1) -- (2) node[pos=0.5, above, sloped] {\footnotesize{$11,(0,0)$}};
    \node (3) at (0,-2) {$(11,(1,0))$};
    \draw[->] (1) -- (3) node[pos=0.5, right] {\footnotesize{$11,(1,0)$}};
    \node (4) at (4,-2) {$(11,(2,0))$};
    \draw[->] (1) -- (4) node[pos=0.5, above, sloped] {\footnotesize{$11,(2,0)$}};
    \node (5) at (-1,-4) {$((11,(1,0)), (12,(0,2)))$};
    \draw[->] (3) -- (5) node[pos=0.5, left] {\footnotesize{$12,(0,2)$}};
    \node (6) at (4,-4) {$((11,(1,0)), (12,(2,0)))$};
    \draw[->] (3) -- (6) node[pos=0.5, above, sloped] {\footnotesize{$12,(2,0)$}};
    \node (7) at (-6,-4) {$((11,(1,0)), (22,(2,0)))$};
    \draw[->] (2) -- (7) node[pos=0.5, above,sloped] {\footnotesize{$22,(2,0)$}};
    \node (8) at (-1,-6) {$((11,(1,0)), (12,(0,2)), (21,(2,0)))$};
    \draw[->] (5) -- (8) node[pos=0.5, left] {\footnotesize{$21,(2,0)$}};
    \end{tikzpicture}
    \caption{Strom algoritmu pro [2,2]-Mastermind.}
\label{figprikladstromualgoritmu}
\end{figure}

\subsubsection{Zobecnění hledání optimálního algoritmu}
Hledání algoritmu s nejlepším průměrným nebo maximálním počtem pokusů lze převést na hledání stromu algoritmu, který bude mít maximální nebo průměrnou délku cesty od kořene do listu co nejmenší. Strom algoritmu lze navíc najít také jako podgraf rozvinutí multigrafu [n,k]-Mastermindu, který splňuje podmínky z definice stromu algoritmu. Díky tomu lze popsat hledání algoritmů (stromů algoritmů) s nejlepšími výsledky pouze pomocí multigrafu [n,k]-Mastermindu. 

Obdobný postup by šel aplikovat na mnoho dalších her ve formě hádání tajného prvku pomocí pokládání otázek. Nechť máme nějakou množinu prvků $H$ a sadu otázek. Každému prvku přiřadíme pro každou otázku nějakou odpověď. Poté lze sestrojit multigraf na množině podmnožin $H$, kde by hrany byly obarvené otázkou s odpovědí. Pokud by z vrcholu $A$ do vrcholu $B$ vedla hrana $(u,r)$, množina $B$ by byla množina těch prvků z $A$, které mají na otázku $u$ odpověď $r$. 

Problém lze dále zobecnit na situaci, kdy o původním problému nic nevíme, ale máme zadaný nějaký multigraf. Pomocí rozvinutí a následného hledání stromu algoritmu by šlo nalézt optimální algoritmus, který nalezne libovolný prvek původní množiny na co nejmenší počet otázek. Koncový stav lze v tomto případě definovat jako situaci, kdy je obarvení vrcholu rozvinutého multigrafu rovno jednoprvkové množině. Prázdný stav lze interpretovat jako vrchol rozvinutí, který je obarven prázdnou množinou. Zde se odkazujeme na možnost obarvení vrcholů při rozvinutí v poznámce \ref{poznobarvenivrcholurozvinuti} pod definicí rozvinutí.

% Ve chvíli, kdy bychom dostali multigraf vycházející z nějaké množiny prvků a sady otázek a odpovědí vyhovujících pro každý prvek množiny. Hrany by byly obarvené otázkou s odpovědí a množina prvků, do které by hrana vedla by byla právě množina prvků z původní množiny,

% \begin{definice}[Strom algoritmu \text{[n,k]-Mastermindu}]
%   Řekneme, že souvislý podgraf $T$ rozvinutí multigrafu [n,k]-Mastermindu je strom algoritmu, pokud splňuje následující podmínky.
%   % Strom algoritmu definujeme jako souvislý podgraf stromu [n,k]-Mastermindu, který splňuje následující podmínky.
%   \begin{enumerate}
%       \item Neobsahuje vrcholy obarvené prázdnou množinou.
%       \item Hrany vedoucí z každého vrcholu grafu $T$ jsou obarveny nejvýše jedním kódem. 
%       \item Pro každý kód $w \in H_{n,k}$ má graf $T$ právě jeden koncový stav s posledním členem $(w, (n,0))$, který je zároveň listem v grafu $T$.
%   \end{enumerate}
% \end{definice}


% Uvažujme nějaký algoritmus, který pro každý stav, do kterého se za použití algoritmu můžeme dostat, vybere deterministicky nějaký další pokus. Strom algoritmu lze sestrojit rekurzivně. Pro každý stav $A$ algoritmus nalezne další pokus $u_A$. Do stromu zakreslíme všechny neprázdné následníky stavu $A$ vzhledem k $u_A$.




\section{Obecný algoritmus}
Nyní přistoupíme k popisu skupiny deterministických algoritmů řešící hru [n,k]-Mastermind. V této práci popisujeme algoritmy, které pro libovolný stav $A$ vybírají další pokus podle množiny kandidátů stavu $A$. 
Pro dva různé stavy, které ale mají shodnou množinu kandidátů je problém nalezení dalšího kódu ekvivalentní. Předpokládáme totiž, že všechny kódy mohou být tajným kódem se stejnou pravděpodobností. 
Tento výběr popíšeme pomocí dvou funkcí, valuace a strategie. 


% Algoritmy popisujeme podle funkcí, které pro jakýkoliv stav naleznou další pokus. Nazýváme je, valuace a strategie. 

% Tyto funkce definujeme pro množiny kandidátů stavů. 

% Množiny kandidátů pro nás budou sloužit jako vnitřní stavy, pomocí kterých vybíráme další pokusy. Pro dva různé stavy, které ale mají shodnou množinu kandidátů je problém nalezení dalšího kódu ekvivalentní. Předpokládáme totiž, že všechny kódy mohou být tajným kódem se stejnou pravděpodobností. 



% Pro zjednodušení tyto funkce definujeme pro množiny kandidátů stavů. Pro dva různé stavy, které ale mají shodnou množinu kandidátů je problém nalezení dalšího kódu ekvivalentní. Předpokládáme totiž, že všechny kódy mohou být tajným kódem se stejnou pravděpodobností. Stejné množiny kandidátů pro dva různé stavy lze například dosáhnout prohozením prvků stavu. 

% Ve chvíli, kdy mají nějaké dva stavy stejnou množinu kandidátů, nezáleží na tom, jaké prvky stav obsahuje. Platí, že při následném zvolení stejných pokusů pro oba stavy dosáhneme stejného výsledku. Dojdeme ke stejnému konečnéme stavu.

% Pro dva různé stavy, které ale mají shodnou množinu kandidátů je problém nalezení dalšího kódu ekvivalentní. Předpokládáme totiž, že všechny kódy mohou být tajným kódem se stejnou pravděpodobností. Stejné množiny kandidátů pro dva různé stavy lze například dosáhnout prohozením prvků stavu. 


% K popisu výběru dalšího tahu algoritmy nebudou používat stav hry jako v definici \ref{defstav}. Místo toho vybírají další kód za pomocí množiny kandidátů tohoto stavu. 

% Našim cílem je totiž co nejlépe rozlišit, který kandidát je tajným kódem. Různé stavy které ale mají stejnou množinu kandidátů se v této informaci neliší. Proto výběr dalšího tahu lze vztáhnout pouze na množinu kandidátů aktuálního stavu. 



% U této definice si nejsem jistý, jak to smyslupně definovat. Vazba "která lz e vyjádřit pomocí potomků" se mi moc nelíbí - definovat valuaci a až potom jednokrokové valuace
\begin{definice}[Valuace]
    Nechť $G = (V,E)$ je graf [n,k]-Mastermindu a $K \in V$ je vrchol. Potom valuaci vzhledem k množině $K$ definujeme jako funkci $f_K(u) \colon H_{n,k} \to \mathbb{R}$.
\end{definice}


Valuace bude v algoritmech sloužit pro vyčíslení vhodnosti kódu $u$ jako dalšího pokusu pro stav s množinou kandidátů $K\subseteq H_{n,k}$. Tato hodnota bude obvykle záviset na potomcích $K$ vzhledem ke kódu $u$. Valuaci tedy lze interpretovat jako funkci, která nahlíží v multigrafu [n,k]-Mastermindu do následujících vrcholů.

% Valuace nám umožňuje ohodnotit kód podle toho, jak dobré jsou jeho následující stavy. Valuace by nemusela být omezená na následující vrstvu. Mohla by odkazovat na stavy o více než jednu hranu dál.

\begin{prikl}\label{prjednokrokfce}
    Funkce $f_K$ je příklad valuace, která kódu $u$ přiřadí maximální počet kódů potomka $K$ vzhledem ke kódu $u$.
    % jednokrokov8 funkce je taková, která kódu $u$ přiřadí hodnotu, která lze vyjádřit pomocí potomků $K$ vzhledem ke kódu $u$.
    \begin{align*}
        f_K \colon H_{n,k} &\to \mathbb{R} \\
        u &\mapsto \max_{r\in S} |K_{u,r}|
    \end{align*}
    % Pro $K = H_{2,2}$ z obrázku \ref{fig22prvnitah} má $f_{K}$ konstantní hodnotu $\frac{3}{2}$.
\end{prikl}
% množinu kandidátů na tajný kód


\begin{definice}[Strategie]
    Nechť $\mathcal{F} = \{f_K\colon H_{n,k} \to \mathbb{R} \mid K \subseteq H_{n,k}\}$ je prostor valuací. Potom řekneme, že zobrazení $F \colon \mathcal{F} \to \mathbb{R}$ je strategie, pokud pro každou $f_K \in \mathcal{F}$ existuje $u\in H_{n,k}$ takové, že $F(f_K) = f_K(u)$.
\end{definice}
% Strategie určitým způsobem slouží k výběru následujícího kódu. 
%Zjednodušeně řečeno slouží k určení, 
Strategie určuje kritérium, podle kterého se vybírá další pokus. Algoritmy budou vybírat právě ty kódy, které mají valuaci rovnou hodnotě strategie pro aktuální množinu kandidátů. 

% v této práci bude určovat, zda chceme vybírat kódy s vyšší nebo nižší hodnotou valuace.
%Použití bude popsáno níže v popisu algoritmu \ref{alg-default}. 

\begin{prikl}\label{prstrategie}
    Funkce $F$ je strategie, která valuaci $f_K$ přiřadí její maximální hodnotu na $H_{n,k}$.
    \[F(f_K) =  \max_{u\in H_{n,k}} f_K(u)\]
    Strategie je dobře definovaná, protože maximum na konečné množině reálných čísel má vždy jednoznačně určenou hodnotu a existuje $u\in H_{n,k}$, pro který platí $f_K(u) = \max_{u\in H_{n,k}} f_K(u)$.
\end{prikl}

\begin{definice}[Deterministický algoritmus]\label{defobecnyalg}
    Deterministický algoritmus řešící [n,k]-Mastermind s prostorem valuací $\mathcal{F}$ a strategií $F$ je definovaný jako funkce, která tajnému kódu $v$ přiřadí posloupnost zahraných kódů s ohodnoceními $\textsc{Solve}[n, k, \mathcal{F}, F](v)$, podle předpisu algoritmu \ref{alg-default}.
    
    % podle předpisu funkce \textsc{Solve} v algoritmu \ref{alg-default} jako
    % % definujeme jako algoritmus se zvoleným prostorem valuací $\mathcal{F}$ a zvolenou strategií $F$ popsaný pro vstupní tajný kód $v$ v algoritmu \ref{alg-default}. 
    % \begin{align*}
    %     \textsc{Solve}[n, k, \mathcal{F}, F] \colon H_{n,k} &\to \mathbb{N} \\
    %     v & \mapsto \textsc{Solve}[n, k, \mathcal{F}, F](v).
    % \end{align*}
    
    % které pro následující pokus vybírají kód podle zvolené valuace a strategie. Postup je znázorněn v algoritmu \ref{alg-default}.
    
\end{definice}
\begin{pozn}
    Důkaz správnosti algoritmu bude sestrojen pro konkrétní volby valuace a strategie v následující kapitole. 
\end{pozn}


% \subsection{Varianty algoritmů}





%Nechť \[P = \left((u_1, r_1), (u_2,r_2), \dots, (u_j,r_j)\right), u_i \in H_{n,k}, r_i \in \N _0 \times \N _0\] jsou tahy s ohodnocením a $K$ je konec cesty $P$ z vrcholu $H_{n,k}$. 

%Potom jednokrokové strategie volí další kód ten, který minimalizuje respektive maximalizuje funkci $f_K$. Pokud je těchto kódů více, zvolí kód, který je zároveň kandidát cesty $P$. Pokud výběr stále není jednoznačný, algoritmus zvolí lexikograficky nejnižší kód. 

\begin{algorithm}[h!]
\begin{algorithmic}[1]  % [1] způsobí, že číslujeme kroky algoritmu
\Function{Solve$[n, k, \mathcal{F}, F]$}{$v$}
    \State $K \gets H_{n,k}$ 
    \State $j \gets 0$
    \State $r_0 \gets (0,0)$
    \While {$r_j \neq (n,0)$} \hfill \mbox{(dokud hra není dohrána)}
        \State $j \gets j + 1$ 
	\State $U \gets \{u \in H_{n,k} \mid f_K(u) = F(f_K)\}$
        \If{$U \cap K \neq \emptyset$}
            \State $u_j \gets$ lexikograficky nejmenší $u \in U \cap K$
	\Else
		\State $u_j \gets$ lexikograficky nejmenší $u \in U$
	\EndIf
        \State $r_j \gets s(u_j, v)$ \hfill \mbox{(ohodnocení pokusu)}
        \State $K \gets K_{u_j,r_j}$
    \EndWhile
    \State \Return $((u_1,r_1),\dots,(u_j, r_j))$ \hfill \mbox{($j$ je počet pokusů a $u_j$ je tajný kód)}
\EndFunction
\end{algorithmic}
\caption{Deterministický algoritmus řešící [n,k]-Mastermind}
\label{alg-default}
\end{algorithm}

Písmenem $K$ značíme množinu kandidátů na tajný kód pro aktuální stav hry. Ta vždy odpovídá aktuálnímu stavu díky lemmatu \ref{lemmavztahnaslednikuapotomku} o vztahu mezi následníky stavů a potomky množin kandidátů. Tajný kód $v$ náleží do množiny kandidátů $K$ v každé iteraci, protože 
\[v \in K_{u_j, s(u_j,v)} = K_{u_j, r_j}.\]

Hra začíná s počátečním stavem, a tedy počáteční množina kandidátů v algoritmu je $K = H_{n,k}$. Kód, který algoritmus zvolí jako j-tý pokus značíme $u_j$. Jeho ohodnocení vzhledem k tajnému kódu $v$ značíme $r_j$. Množina $U$ značí kódy, ve kterých valuace $f_K$ nabývá nejlepší hodnotu danou strategií $F$. Z této množiny algoritmus vybírá další pokus $u_j$. Ve chvíli, kdy existuje kandidát v množině $U$ ($U\cap K \neq \emptyset$), algoritmus zvolí ten, který je lexikograficky nejmenší. V opačném případě algoritmus volí lexikograficky nejmenší kód z $U$. Množina $U$ nikdy nebude prázdná díky podmínce z definice strategie (valuace $f_K$ nabývá hodnotu strategie $F(f_K)$). 

% ================= šlo by přidat/změnit definici determ.alg. ================
Obecně tedy platí, že deterministický algoritmus s prostorem valuací $\mathcal{F}$ a strategií $F$ je takový algoritmus, který pro stav $A$ s množinou kandidátů $K$ volí další pokus z množiny $U = \{u \in H_{n,k} \mid f_K(u) = F(f_K)\}$. Pokud $U \cap K \neq \emptyset$, volí lexikograficky nejmenší $u \in U \cap K$, jinak volí lexikograficky nejmenší $u \in U$. 


% šlo by napsat pro dvojice funkce f, funkcionál F
%\begin{veta}[Správnost algoritmu \ref{alg-default}]
 %   Algoritmus \ref{alg-default}
%\end{veta}

% \begin{tvrz}[Počet ohodnocení]
% Nechť $n\in \mathbb{N}, k\in \mathbb{N}, k \geq 3$. Potom počet všech možných ohodnocení kódů v $H_{n,k}$ je $\frac{n^2 + 3n}{2}$.
% \end{tvrz}
% \begin{dukaz}
% Pro $b \leq n,\hspace{3px} b \neq n-1$ černých kolíčků existuje $n-b+1$ možností na počet bílých kolíčků podle tvrzení \ref{tvrzohodnoceni}. Pro $b = n-1$ existuje pouze jedno ohodnocení. Součtem přes počet černých kolíčků dostáváme následující počet možností ohodnocení.
%     \[|S| = (n+1) + n + (n-1)  + \dots + 3 + 1 + 1 \]
% Vzorcem pro součet aritmetické řady se dobereme k výsledku.
%     \[|S| = \frac{(n+1)(n+2)}{2} - 1 \]
%     \[|S| = \frac{n^2 + 3n}{2}\]
% \end{dukaz}

% \begin{tvrz}[Časová složitost algoritmu \ref{alg-default}]
%     Uvažujeme případ, kdy $F$ je minimizér/maximizér.
%     Algoritmus \ref{alg-default} má časovou složitost
%     % \[O( k^n O(f_K))\]
%     \[O \left( \sum_{j = 1}^z k^n \cdot m_j \cdot n^2 \cdot \frac{n^2 + 3n}{2}\right)\]
    
% \end{tvrz}
% \begin{dukaz}
%     $k^n$ je počet všech kódů, které musím projít, abych našel ten nejlepší, $m_j$ je maximální počet kandidátů v j-té iteraci, $z$ je maximální počet iterací algoritmu. $\frac{n^2 + 3n}{2}$ je počet všech ohodnocení, $n^2$ je časová složitost ohodnocení.

%     Potřebuji ještě limit na počet iterací $z$, horní odhad na $m_j$ a zjistit složitost nalezení průniku $U$ a $K$.
% \end{dukaz}
